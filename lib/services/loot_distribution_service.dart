// services/loot_distribution_service.dart


import 'dart:math';


import 'package:aravt/models/combat_models.dart';
import 'package:aravt/models/combat_report.dart';
// import 'package:aravt/models/horde_data.dart'; // No longer needed
import 'package:aravt/models/inventory_item.dart';
import 'package:aravt/models/soldier_data.dart';


/// Service to distribute loot to victors after an auto-resolved combat.
class LootDistributionService {
  final Random _random = Random();


  /// Distributes loot from the defeated horde to the victorious horde
  /// based on the combat report.
  ///
  /// This method MODIFIES the Soldier objects within the victoriousSoldiers list.
  ///
  /// [report]: The CombatReport generated by the AutoResolveService.
  /// [victoriousSoldiers]: The complete list of ALL soldiers from the winning side
  /// (e.g., gameState.npcHorde1).
  void distributePostCombatLoot({
    required CombatReport report,
    required List<Soldier> victoriousSoldiers,
  }) {
    // Determine who won
    bool attackerWon = (report.result == CombatResult.playerVictory ||
        report.result == CombatResult.enemyRout);


    final List<CombatReportSoldierSummary> victorSummaries =
        attackerWon ? report.playerSoldiers : report.enemySoldiers;
    final List<CombatReportSoldierSummary> defeatedSummaries =
        attackerWon ? report.enemySoldiers : report.playerSoldiers;


    final Map<String, List<InventoryItem>> personalLootPool = {};
    final List<InventoryItem> generalLootPool = [];
    final Set<int> processedDefeatedSoldierIds = {};


    // --- Phase 1: Distribute Personal Loot (Rule 1) ---
    for (final victorSummary in victorSummaries) {
      // Only living victors get loot
      if (victorSummary.finalStatus == SoldierStatus.killed) continue;


      final victorId = victorSummary.originalSoldier.id;
      personalLootPool.putIfAbsent(victorId.toString(), () => []);


      for (final defeatedSoldier in victorSummary.defeatedSoldiers) {
        // Add this soldier's ID so we don't process them again
        processedDefeatedSoldierIds.add(defeatedSoldier.id);


        // Get their personal loot
        final (List<InventoryItem> loot, List<InventoryItem> remaining) =
            _stripPersonalLoot(defeatedSoldier);


        personalLootPool[victorId.toString()]!.addAll(loot);


        // Add their remaining inventory to the general pool
        generalLootPool.addAll(remaining);
        generalLootPool.addAll(_stripGeneralLoot(defeatedSoldier));
      }
    }


    // --- Phase 2: Collate General Loot Pool (Rule 2) ---
    for (final defeatedSummary in defeatedSummaries) {
      // If they were defeated (killed/wounded/captured) AND
      // they haven't been processed yet (i.e., their killer is unknown or dead)
      if (defeatedSummary.finalStatus != SoldierStatus.alive &&
          !processedDefeatedSoldierIds
              .contains(defeatedSummary.originalSoldier.id)) {
        // Add ALL their items to the general pool
        final (personalLoot, remainingInventory) =
            _stripPersonalLoot(defeatedSummary.originalSoldier);
        generalLootPool.addAll(personalLoot);
        generalLootPool.addAll(remainingInventory);
        generalLootPool.addAll(_stripGeneralLoot(defeatedSummary.originalSoldier));
      }
    }


    // Also add loot from any victors who were killed
    for (final killedVictor
        in victorSummaries.where((s) => s.finalStatus == SoldierStatus.killed)) {
      final (personalLoot, remainingInventory) =
          _stripPersonalLoot(killedVictor.originalSoldier);
      generalLootPool.addAll(personalLoot);
      generalLootPool.addAll(remainingInventory);
      generalLootPool.addAll(_stripGeneralLoot(killedVictor.originalSoldier));
    }


    // --- Phase 3: Distribute General Loot (Rule 3) ---
    if (generalLootPool.isNotEmpty) {
      // Get all living soldiers from the victorious horde list
      List<Soldier> livingVictors = victoriousSoldiers
          .where((s) =>
              s.status == SoldierStatus.alive ||
              s.status == SoldierStatus.wounded)
          .toList();


      if (livingVictors.isNotEmpty) {
        // 1. Calculate scavenge priority for each
        Map<int, double> scavengeScores = {};
        double totalScavengeScore = 0;
        for (final victor in livingVictors) {
          double score = (victor.perception + victor.stress) /
              (victor.patience == 0 ? 0.1 : victor.patience);
          score = score.clamp(0.1, double.maxFinite); // Ensure non-zero
          scavengeScores[victor.id] = score;
          totalScavengeScore += score;
        }


        // 2. Sort loot by "choiceness" (itemValue)
        generalLootPool.sort((a, b) => b.baseValue.compareTo(a.baseValue));


        // 3. Distribute loot based on priority share
        Map<int, List<InventoryItem>> generalLootDistribution = {};
        for (final victor in livingVictors) {
          generalLootDistribution[victor.id] = [];
        }


        // Assign items one by one in a weighted random fashion
        for (final item in generalLootPool) {
          final victorId =
              _getWeightedRandomVictor(scavengeScores, totalScavengeScore);
          if (victorId != null) {
            generalLootDistribution[victorId]!.add(item);
          } else {
            // Fallback: give to a random victor
            livingVictors[_random.nextInt(livingVictors.length)]
                .personalInventory
                .add(item);
          }
        }


        // Add distributed general loot to personal loot pool
        generalLootDistribution.forEach((victorId, items) {
          personalLootPool
              .putIfAbsent(victorId.toString(), () => [])
              .addAll(items);
        });
      }
    }


    // --- Phase 4: Update Soldier Models ---
    // Add all collected loot to the personal inventories of the victors
    personalLootPool.forEach((victorId, items) {
      if (items.isEmpty) return;
      try {
        // Find the soldier in the *victoriousSoldiers* list
        final soldier =
            victoriousSoldiers.firstWhere((s) => s.id == int.parse(victorId));
        soldier.personalInventory.addAll(items);
      } catch (e) {
        print(
            "Error: Could not find victorious soldier $victorId to give loot to.");
      }
    });
  }


  /// Selects a victor ID based on weighted random probability
  int? _getWeightedRandomVictor(Map<int, double> scores, double totalScore) {
    if (scores.isEmpty || totalScore == 0) return null;


    double roll = _random.nextDouble() * totalScore;
    double cumulativeScore = 0;


    for (final entry in scores.entries) {
      cumulativeScore += entry.value;
      if (roll <= cumulativeScore) {
        return entry.key;
      }
    }
    return null; // Should not happen
  }


  /// Removes and returns "personal loot" (equipped items + mount)
  /// from a soldier. Returns the loot and any remaining items.
  (List<InventoryItem>, List<InventoryItem>) _stripPersonalLoot(Soldier soldier) {
    final List<InventoryItem> personalLoot = [];
    final List<InventoryItem> remainingItems = [];


    soldier.equippedItems.forEach((slot, item) {
      // Rule 1: Horses and equipped gear
      if (slot == EquipmentSlot.mount || item.weight > 0) {
        // Simple check
        personalLoot.add(item);
      } else {
        remainingItems.add(item); // e.g., undergarments
      }
    });


    soldier.equippedItems.clear(); // Clear all equipped items
    return (personalLoot, remainingItems);
  }


  /// Removes and returns all items from a soldier's personal inventory.
  List<InventoryItem> _stripGeneralLoot(Soldier soldier) {
    final List<InventoryItem> generalLoot =
        List.from(soldier.personalInventory);
    soldier.personalInventory.clear();
    return generalLoot;
  }
}

