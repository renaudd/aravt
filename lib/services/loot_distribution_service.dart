// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// services/loot_distribution_service.dart

import 'dart:math';

import 'package:aravt/models/combat_models.dart';
import 'package:aravt/models/combat_report.dart';
// import 'package:aravt/models/horde_data.dart'; // No longer needed
import 'package:aravt/models/inventory_item.dart';
import 'package:aravt/models/soldier_data.dart';

/// Service to distribute loot to victors after an auto-resolved combat.
class LootDistributionService {
  final Random _random = Random();

  /// Distributes loot from the defeated horde to the victorious horde
  /// based on the combat report.
  ///
  /// This method MODIFIES the Soldier objects within the victoriousSoldiers list.
  ///
  /// [report]: The CombatReport generated by the AutoResolveService.
  /// [victoriousSoldiers]: The complete list of ALL soldiers from the winning side
  /// (e.g., gameState.npcHorde1).
  LootReport distributePostCombatLoot({
    required CombatReport report,
    required List<Soldier> victoriousSoldiers,
  }) {
    // Determine who won
    bool attackerWon = (report.result == CombatResult.playerVictory ||
        report.result == CombatResult.enemyRout);

    final List<CombatReportSoldierSummary> victorSummaries =
        attackerWon ? report.playerSoldiers : report.enemySoldiers;
    final List<CombatReportSoldierSummary> defeatedSummaries =
        attackerWon ? report.enemySoldiers : report.playerSoldiers;

    final Map<String, List<InventoryItem>> personalLootPool = {};
    final List<InventoryItem> generalLootPool = [];
    final Set<int> processedDefeatedSoldierIds = {};
    final List<LootEntry> lootEntries = [];

    // --- Phase 1: Distribute Personal Loot (Rule 1) ---
    for (final victorSummary in victorSummaries) {
      // Only living victors get loot
      if (victorSummary.finalStatus == SoldierStatus.killed) continue;

      final victorId = victorSummary.originalSoldier.id;
      personalLootPool.putIfAbsent(victorId.toString(), () => []);

      for (final defeatedSoldier in victorSummary.defeatedSoldiers) {
        // Add this soldier's ID so we don't process them again
        processedDefeatedSoldierIds.add(defeatedSoldier.id);

        // Get their personal loot
        final (List<InventoryItem> loot, List<InventoryItem> remaining) =
            _stripPersonalLoot(defeatedSoldier);

        personalLootPool[victorId.toString()]!.addAll(loot);

        // Add their remaining inventory to the general pool
        generalLootPool.addAll(remaining);
        generalLootPool.addAll(_stripGeneralLoot(defeatedSoldier));
      }
    }

    // --- Phase 2: Collate General Loot Pool (Rule 2) ---
    for (final defeatedSummary in defeatedSummaries) {
      // If they were defeated (killed/wounded/captured) AND
      // they haven't been processed yet (i.e., their killer is unknown or dead)
      if (defeatedSummary.finalStatus != SoldierStatus.alive &&
          !processedDefeatedSoldierIds
              .contains(defeatedSummary.originalSoldier.id)) {
        // Add ALL their items to the general pool
        final (personalLoot, remainingInventory) =
            _stripPersonalLoot(defeatedSummary.originalSoldier);
        generalLootPool.addAll(personalLoot);
        generalLootPool.addAll(remainingInventory);
        generalLootPool
            .addAll(_stripGeneralLoot(defeatedSummary.originalSoldier));
      }
    }

    // Also add loot from any victors who were killed
    for (final killedVictor in victorSummaries
        .where((s) => s.finalStatus == SoldierStatus.killed)) {
      final (personalLoot, remainingInventory) =
          _stripPersonalLoot(killedVictor.originalSoldier);
      generalLootPool.addAll(personalLoot);
      generalLootPool.addAll(remainingInventory);
      generalLootPool.addAll(_stripGeneralLoot(killedVictor.originalSoldier));
    }

    // --- Phase 3: Distribute General Loot (Rule 3) ---
    if (generalLootPool.isNotEmpty) {
      // Get all living soldiers from the victorious horde list
      List<Soldier> livingVictors = victoriousSoldiers
          .where((s) =>
              s.status == SoldierStatus.alive ||
              s.status == SoldierStatus.wounded)
          .toList();

      if (livingVictors.isNotEmpty) {
        // 1. Calculate scavenge priority for each
        Map<int, double> scavengeScores = {};
        double totalScavengeScore = 0;
        for (final victor in livingVictors) {
          double score = (victor.perception + victor.stress) /
              (victor.patience == 0 ? 0.1 : victor.patience);
          score = score.clamp(0.1, double.maxFinite); // Ensure non-zero
          scavengeScores[victor.id] = score;
          totalScavengeScore += score;
        }

        // 2. Sort loot by "choiceness" (itemValue)
        generalLootPool.sort((a, b) => b.baseValue.compareTo(a.baseValue));

        // 3. Distribute loot based on priority share
        Map<int, List<InventoryItem>> generalLootDistribution = {};
        for (final victor in livingVictors) {
          generalLootDistribution[victor.id] = [];
        }

        // Assign items one by one in a weighted random fashion
        //  Prioritize horses for winning Aravt members if applicable
        final List<InventoryItem> horses =
            generalLootPool.where((i) => i.itemType == ItemType.mount).toList();
        final List<InventoryItem> otherLoot =
            generalLootPool.where((i) => i.itemType != ItemType.mount).toList();

        // Distribute horses first, weighted towards winning Aravt members if we can identify them,
        // but for now we'll just use the general scavenge scores as they are already weighted.
        // Actually, the requirement is "winning Aravt receives horses".
        // If we are in player's horde, we might want to prioritize the specific Aravt that did the most work,
        // but currently we don't track that easily. We will just ensure horses go to victors.

        for (final item in horses) {
          final victorId =
              _getWeightedRandomVictor(scavengeScores, totalScavengeScore);
          if (victorId != null) {
            generalLootDistribution[victorId]!.add(item);
          } else {
            livingVictors[_random.nextInt(livingVictors.length)]
                .personalInventory
                .add(item);
          }
        }

        for (final item in otherLoot) {
          final victorId =
              _getWeightedRandomVictor(scavengeScores, totalScavengeScore);
          if (victorId != null) {
            generalLootDistribution[victorId]!.add(item);
          } else {
            livingVictors[_random.nextInt(livingVictors.length)]
                .personalInventory
                .add(item);
          }
        }

        // Add distributed general loot to personal loot pool
        generalLootDistribution.forEach((victorId, items) {
          personalLootPool
              .putIfAbsent(victorId.toString(), () => [])
              .addAll(items);
        });
      }
    }

    // --- Phase 4: Update Soldier Models and Track Loot ---
    // Add all collected loot to the personal inventories of the victors
    personalLootPool.forEach((victorId, items) {
      if (items.isEmpty) return;
      try {
        // Find the soldier in the *victoriousSoldiers* list
        final soldier =
            victoriousSoldiers.firstWhere((s) => s.id == int.parse(victorId));
        soldier.personalInventory.addAll(items);

        // Track loot for report
        for (final item in items) {
          lootEntries.add(LootEntry(
            soldierId: soldier.id,
            soldierName: soldier.name,
            item: item,
          ));
        }
      } catch (e) {
        print(
            "Error: Could not find victorious soldier $victorId to give loot to.");
      }
    });

    return LootReport(
      currency: 0, // Implement currency loot if needed later
      entries: lootEntries,
    );
  }

  /// Selects a victor ID based on weighted random probability
  int? _getWeightedRandomVictor(Map<int, double> scores, double totalScore) {
    if (scores.isEmpty || totalScore == 0) return null;

    double roll = _random.nextDouble() * totalScore;
    double cumulativeScore = 0;

    for (final entry in scores.entries) {
      cumulativeScore += entry.value;
      if (roll <= cumulativeScore) {
        return entry.key;
      }
    }
    return null; // Should not happen
  }

  /// Removes and returns "personal loot" (equipped items + mount)
  /// from a soldier. Returns the loot and any remaining items.
  (List<InventoryItem>, List<InventoryItem>) _stripPersonalLoot(
      Soldier soldier) {
    final List<InventoryItem> personalLoot = [];
    final List<InventoryItem> remainingItems = [];

    soldier.equippedItems.forEach((slot, item) {
      // Rule 1: Horses and equipped gear
      if (slot == EquipmentSlot.mount || item.weight > 0) {
        // Simple check
        personalLoot.add(item);
      } else {
        remainingItems.add(item); // e.g., undergarments
      }
    });

    soldier.equippedItems.clear(); // Clear all equipped items
    return (personalLoot, remainingItems);
  }

  /// Removes and returns all items from a soldier's personal inventory.
  List<InventoryItem> _stripGeneralLoot(Soldier soldier) {
    final List<InventoryItem> generalLoot =
        List.from(soldier.personalInventory);
    soldier.personalInventory.clear();
    return generalLoot;
  }
}
